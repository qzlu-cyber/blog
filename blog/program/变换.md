---
slug: transform
title: 坐标空间变换
date: 2023-09-14
authors: Kaesar
tags: [CG, Rendering, MVP, Transform]
keywords: [变换, 坐标空间]
---
### 1. 齐次坐标

矩阵的缩放、旋转是线性变换，而平移是非线性的，为了将三种变换统一形式引入了齐次坐标。

- 二维坐标系下的一个点 $P(x, y, 1)^T$，在齐次坐标下，$(x, y, w)^T$ (w ≠ 0)是一个二维的点，坐标为 $(x/w, y/w, 1)^T$；另外，两点相加得到的是它们的中点。
- 二位坐标系下的向量 $V(x, y, 0)^T$，向量平移的不变性。

### 2. 变换

1. 绕 X、Y、Z 轴旋转：

   $$
   R_{x}(α) = \begin{pmatrix}
   1 & 0 & 0 & 0 \\
   0 & cos(α) & -sin(α) & 0 \\
   0 & sin(α) & cos(α) & 0 \\
   0 & 0 & 0 & 1 \\
   \end{pmatrix}
   $$

   $$
   R_{y}(α) = \begin{pmatrix}
   cos(α) & 0 & sin(α) & 0 \\
   0 & 1 & 0 & 0 \\
   -sin(α) & 0 & cos(α) & 0 \\
   0 & 0 & 0 & 1 \\
   \end{pmatrix}
   $$

   $$
   R_{z}(α) = \begin{pmatrix}
   cos(α) & -sin(α) & 0 & 0 \\
   sin(α) & cos(α) & 0 & 0 \\
   0 & 0 & 1 & 0 \\
   0 & 0 & 0 & 1 \\
   \end{pmatrix}
   $$
2. 平移

   ![平移](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151852434.png)
3. 缩放

   ![缩放](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151854729.png)

复合变换的顺序为**先缩放后旋转再平移**，即 **$P_{new}$ = $M_t$ $M_r$ $M_s$ $P_{old}$**

### 3. 坐标空间

在渲染流水线中，顶点着色器承担把网格的顶点从模型空间（Model）最终转换到齐次裁剪坐标空间中，再经由视口变换后会被映射到屏幕空间中，再经过着色后模型就会被成功渲染出来，所以渲染的过程也可以看成是处理顶点将其转换到屏幕的过程。

#### 3.1 坐标空间的变换

定义一个坐标空间，必须有其原点和三条坐标轴。而这些值又是相对于其它坐标空间而言的，也即是说坐标空间之间会形成一个层次结构，每个坐标空间都是另一个的子空间。对坐标空间的变换实则就是在父空间和子空间之间对点或矢量进行变换。

给定一个父空间 **P** 和一个子空间 **C** （此时，子空间的原点和三条坐标轴是已知的）。

- 将子空间的矢量变换到父空间：**$A_P$ = $M_{C→P}$ $A_C$**
- 将父空间的矢量变换到子空间：**$A_C$ = $M_{P→C}$~ $A_P$**

以 **$A_P$ = $M_{C→P}$ $A_C$** 为例，求 **$M_{C→P}$**

假设 $A_C$ (*a*, *b*, *c*)，C 空间的原点为 ***$O_C$*** ，则  $A_P$ 可以以另一种方式表述：

1. 从原点 ***$O_C$*** 出发
2. 向 X 轴方向移动 *a* 个单位，可以得到  ***$O_C$ + a$X_C$***
3. 向 Y 轴方向移动 *b* 个单位，可以得到  ***$O_C$ + a$X_C$ + b$Y_C$***
4. 向 Z 轴方向移动 *c* 个单位，可以得到  ***$O_C$ + a$X_C$ + b$Y_C$ + c$Z_C$***

**$A_P$ = $O_C$ + a$X_C$ + b$Y_C$ + c$Z_C$**

![变换矩阵推导](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151856400.png)

可以看到，$M_{C→P}$ 可以由 空间 C 在空间 P 中的原点和坐标轴表示出来。反之，当已知从子空间到父空间的变换矩阵可以提取它的前三列再归一化后来获取子空间在其父空间的坐标轴的单位矢量表示（例如模型空间和世界空间）。

**平移不会对矢量造成影响，所以对矢量进行变换只需变换矩阵的前三列即可。**

 **$M_{P→C}$ = $(M_{C→P})^{-1}$**, 当 $M_{C→P}$ 为正交矩阵时，$(M_{C→P})^{-1}$ = $(M_{C→P})^T$ ，可以不用求逆就可以得到反向变换矩阵。此时，$M_{C→P}$ 矩阵的每一行就是父空间的坐标轴在子空间的表示。

#### 3.2 顶点的坐标空间变换过程

- 模型空间（Model），每个模型的独立坐标空间，模型空间的原点和坐标轴是在建模软件中确定好的，例如 .obj 文件中的顶点坐标都是相对于模型空间的。
- 世界空间（World），用来描述绝对位置。顶点变换第一步就是将模型空间变换到世界空间，也叫**模型变换**。模型变换用来固定模型，通俗来说就是给模型摆好 Pose。

  ![模型变换](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151857198.png)

  如上图，根据变换组件中的信息可以得出，Marry 在世界空间中进行了 (2, 2, 2) 的缩放，又进行了 (0, 45, 0) 的旋转，最后又做了 (2, 0, 3) 的平移。根据这些数据，即可构建出模型变换矩阵 **$M_{model}$** ：

  ![模型变换矩阵](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151857335.png)

  **$P_{world}$ = $M_{model}$ $P_{model}$**
- 观察空间（View），又叫摄像机空间，将世界空间变换到观察空间称为观察变换或相机变换。在观察空间中，摄像机位于原点，摄像机决定了渲染时所使用的视角，所以可以将相机变化通俗的理解为调整相机角度。

  有两种方法可以得到顶点在观察空间中的位置：

  1. 构建出从观察空间变换到世界空间的变换矩阵，再对矩阵求逆；
  2. 想象集体拍合照，如果把相机和整个世界一起变换，得到的照片是一样的，所以把相机变换到新坐标系的原点，其他的物体也做同样的变化。所以，让相机的原点位于世界坐标的原点，坐标轴与世界空间坐标轴重合即可。

     ![相机变换](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151858183.png)

     可以看到我在引擎中初始化的相机的各项参数，相机先旋转（Yaw、Pitch）然后又按 (-1.28, 4.40, 8.89) 进行了平移。因此，为了把相机重新移回初始状态，即让相机的原点位于世界坐标的原点，坐标轴与世界空间坐标轴重合，就要进行逆向变换。先按  (1.28, -4.40, -8.89) 进行平移，将相机移回原点，再逆向旋转即可。

     ![视图变换矩阵](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151858090.png)

     **$M_{view}$ = $R_{view}$ $T_{view}$**

     **$P_{view}$ = $M_{view}$ $P_{world}$**
- 裁剪空间（Clip），又称为齐次裁剪空间，目的是对渲染的图元进行裁剪：完全位于这块空间内部的将会保留，部分位于的将会裁剪，完全位于外部的将会被剔除。这块空间由视锥体决定，透视投影（Perspective projection）的视锥体是一个四棱锥，正交投影（Orthographic projection）的视锥体是一个长方体。变换矩阵称为投影矩阵。

  视锥体决定了摄像机可以看到的空间。

  如果直接使用视锥体定义的空间进行裁剪，那么不同的视锥体就需要不同的处理过程，而且对于透视投影的视锥体来说，想判断一个点是否位于四棱锥内部很麻烦。所以，利用一个投影矩阵把顶点转换到一个裁剪空间中更加方便。

  ![两种视锥体](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151858532.png)

  **投影矩阵是为投影做准备，并没有真正进行投影工作。真正的投影操作发生在后面的齐次除法过程。**

  1. 透视投影

     闫令琪老师在 GAMES101 课程中给出了一种通俗易懂的透视矩阵推导方式，分为三步：

     1. 将平截头体挤压成一个长方体（压缩远平面，挤压过程为一个齐次矩阵 $M_{P2O}$）
     2. 对长方体做一个正交投影（正交投影则仅是一个普通的缩放平移矩阵，正交投影也是一个齐次矩阵 $M_{Ortho}$）
     3. 最后可算出透视矩阵：$M_{Persp}$ = $M_{Ortho}$ *  $M_{P2O}$

     ![挤压矩阵](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151859906.jpeg)

     ![透视投影矩阵](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151901559.jpeg)
  2. 正交投影

     ![正交投影矩阵](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151902375.jpeg)

  **$P_{clip}$ = $M_p$ $P_{view}$**

  得到顶点在裁剪空间的坐标后，将 *x 、y、z* 分量分别与 *w* 分量相比满足 *-w ≤ x ≤ w, -w ≤ y ≤ w, -w ≤ z ≤ w* 则不需要裁剪。
- 屏幕空间（Screen），变换之后随即进行裁剪操作，完成所有裁剪后进行投影。把视锥体投影到屏幕空间后就会得到真正的像素位置。此过程需要两步

  1. 齐次除法（homogeneous division），也叫透视除法（perspective division），用来将坐标从齐次裁剪空间转换到 **NDC** (Normalized Device Coordinates，归一化设备坐标) 中。具体做法就是 *x 、y、z* 分量分别除以 *w* 分量，之后裁剪空间会被变换到一个立方体内。

     <img src="https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151903549.png" alt="齐次除法" style="width:80%;" />

     <br/>
     
  2. 视口变换，屏幕空间左下角像素坐标是 (0, 0)，右上角是 (width, height)，经过齐次除法后的坐标都在 [-1, 1] 之间，因此还需要对坐标进行缩放操作。

     ![视口变换](https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151904716.jpeg)

  总结两步的操作：

  $$
  Xscreen = Xclip \div Wclip \times width \div 2 + width \div 2
  $$

  $$
  Yscreen = Yclip \div Wclip \times height \div 2 + height \div 2
  $$

### 4. 法线变换

点和大部分矢量一般都可以经由变换矩阵 M 变换到其它坐标空间中，但是法线矢量在变换时可能会无法保证变换后依然垂直，造成错误。

<img src="https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202309151904271.png" alt="错误的法线变换" style="width:80%;" />

<br/>

由于切线是由两个顶点的差值计算得来的，因此可以直接使用用于顶点变换的矩阵对切线矢量进行变换。

**$T_B$ = $M_{A→B}$ $T_A$** ，由于 *dot($T_A$, $N_A$)* = 0，现在要找到一个矩阵 G 来变换法线 $N_A$，即 **$T_B$ · $N_B$ = ($M_{A→B}$ $T_A$) · (G $N_A$)** = 0。

**($M_{A→B}$ $T_A$) · (G $N_A$) = $(M_{A→B}$ $T_A)^T$ · (G $N_A$)  = $T_A^T$ $M_{A→B}^T$ G $N_A$ =  ${T_A}^T$ ($M_{A→B}^T$ G) $N_A$ = 0**

由于 $T_A$· $N_A$ = 0，因此如果 $M_{A→B}^T$ G = I，那么上式成立，即 **G = $({M_{A→B}}^T)^{-1}$ =  $({M_{A→B}}^{-1})^T$**，即使用原来变换矩阵的逆转置矩阵变换法线就能得到正确的结果。

如果原变换矩阵只包含旋转变换，那么 $M_{A→B}$ 为正交矩阵，则 $({M_{A→B}}^{-1})^T$ = $M_{A→B}$；如果只包含旋转和统一缩放，则 $({M_{A→B}}^{-1})^T$ = 1/k * $M_{A→B}$；否则必须要求解原变换矩阵的逆转置矩阵来求得用于变换法线的矩阵。
