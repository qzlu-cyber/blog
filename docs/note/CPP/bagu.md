---
    slug: bagu
    title: C++ 面试八股
    date: 2024-03-13
    authors: Kaesar
    tags: [C++]
    keywords: [C++, 虚函数, 智能指针, STL]
---

## C++ 八股

### C++

#### **1.1 封装、继承、多态、虚函数**

- **封装继承多态**

  **封装**（Encapsulation）：封装是将数据和操作（方法）包装在一个单元（类）中，以实现数据的隐藏和保护。通过封装，我们可以将数据隐藏在类内部，并提供公共接口来访问和操作这些数据，从而实现了信息隐藏、数据安全性和代码模块化的目标。

  **继承**（Inheritance）：继承允许一个类派生出子类，并从父类继承其属性和行为。子类可以使用父类已有的特性，并根据需要添加自己独特的属性和方法。通过继承机制，可以实现代码重用、层次结构组织等目标。

  **多态**：就是同一个函数名具有多种状态，或者说一个接口具有不同的行为。

- **什么是多态？C++的多态是如何实现的？**

  答：所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为；C++的多态分为编译时多态和运行时多态，编译时多态也称为为静态联编，通过重载和模板来实现，运行时多态称为动态联编，通过继承和虚函数来实现。虚函数是在基类中声明并用 `virtual` 关键字进行标记的成员函数。派生类可以覆盖该虚函数，并根据需要提供自己的实现。通过使用指向基类对象的指针或引用调用虚函数时，程序将根据运行时实际对象类型来确定要调用的函数。

- **虚函数的实现机制是什么？**

  答：虚函数是通过虚函数表来实现的，在编译时生成。虚函数表包含了一个类(所有)的虚函数的地址，在有虚函数的类对象中，它内存空间的头部会有一个虚表指针，用来管理虚函数表。当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数。

- **虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？**

  答：通过指针或者引用的方式调用虚函数是运行时确定，通过值调用的虚函数是编译期就可以确定的，通过查找虚函数表中的函数地址确定。

- **虚函数是存在类中还是类对象中（即是否共享虚表）？**

  答：存在类中，不同的类对象共享一张虚函数表(为了节省内存空间)，类之间不共享虚函数表。

- **在基类的构造函数和析构函数中调用虚函数会怎么样？**

  答：从语法上讲，调用没有问题，但是从效果上看，往往不能达到需要的目的（不能实现多态）；因为调用构造函数的时候，是先进行父类成分的构造，再进行子类的构造。在父类构造期间，子类的特有成分还没有被初化，如果虚函数依赖于子类特有的成员变量或状态，使用这些尚未初始化的数据一定会出错；同理，调用析构函数的时候，先对子类的成分进行析构，当进入父类的析构函数的时候，子类的特有成分已经销毁，此时是无法再调用虚函数实现多态的。

- **父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？**

  答：构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的 `vptr` 指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找 `vptr`，但此时 `vptr` 还没有完成初始化，导致无法构造对象。

  析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。

- **类中static函数是否能声明为虚函数？**

  答：不能，因为类中的`static`函数是所有类实例化对象所共有的，没有`this`指针，而虚函数依靠`vptr`和`vtable`来处理，`vptr` 在类中的构造函数中生成，并且只能通过`this`指针访问，因此static函数无法声明为虚函数。

- **哪些函数不能被声明为虚函数？**

  答：构造函数，内联函数（内联函数有实体，在编译时展开，没有this指针），成员模板函数，静态成员函数，友元函数（C++不支持友元函数的继承，不能继承的函数指定不是虚函数），非类成员函数。

- **如果一个函数是成员模板函数，可以被声明为虚函数吗？**

  答：成员模板函数**不能**被声明为虚函数。虚函数机制要求在编译时知道派生类中对基类虚函数的具体重写情况，以便构建虚函数表，而模板成员函数的实例化发生在编译时期的后期，直到模板被具体实例化时才生成代码。因此，编译器无法提前知道所有可能的模板实例化情况来构建虚函数表。

#### 1.2 **内存模型，继承问题**

- **C++中类对象的内存模型(布局)是怎么样的？**

  答：一般遵循以下几点原则：

  （1）如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部；

  （2）除了虚函数之外，内存空间会按照类的继承顺序(父类到子类)和字段的声明顺序布局；

  （3）如果有多继承，如下情况：`Derived`类的对象需要包含两个虚表指针：一个指向`Derived`类作为`Base1`的部分的虚表，另一个指向`Derived`类作为`Base2`的部分的虚表。这是因为`Derived`对象需要能够通过`Base1*`或`Base2*`类型的指针正确地访问其虚函数，且这些虚函数可能已经在`Derived`中被重写。在对象的内存布局中，第一个虚表指针（对应第一个基类`Base1`）通常位于对象的开始位置，紧接着是`Base1`的成员变量（如果有的话），然后是第二个虚表指针（对应第二个基类`Base2`）以及`Base2`的成员变量。之后才是`Derived`类自己的成员变量，如果`Derived`类有自己的虚函数，那么编译器会将它的虚函数表给合并到第一个具有虚函数的基类的虚表中！此例中

  <img src="https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202403141755616.png"/>

  ```cpp
  class Base1 {
  public:
      virtual void func1() {}
  };
  
  class Base2 {
  public:
      virtual void func2() {}
  };
  
  class Derived1 : public Base1, public Base2 {
  public:
      virtual void func1() override {}
      virtual void func2() override {}
      virtual void func3() {}
  };
  ```

  如果`Derived`类有三个父类，且它们分别没有、有、没有虚函数，那么基类2会存在`Derived`类对象内存空间的开头。

  （4）如果有菱形继承，情况太多，总结就是：两个父类都会有指向虚基类的虚基表指针，排列顺序为 父类1（虚基表指针+虚表指针+成员）--父类2（虚基表指针+虚表指针+成员）--子类（成员）--虚基类（虚基类自身的虚表指针+成员），如果子类有自己的虚函数，也会挂到第一个有虚函数的父类的虚表中。

  ```cpp
  class A;                       // 没有虚函数
  class B : virtual public A;    // 没有虚函数
  class C : virtual public A;    // 没有虚函数
  class D : public B, public C;  // 没有虚函数
  ```

  <img src="https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202403141756076.png" style="zoom:70%;"/>

  

- **钻石(菱形)继承存在什么问题，如何解决**？

  答：会存在二义性的问题，因为两个父类都会对公共基类的数据和方法产生一份拷贝，因此对于子类来说读写一个公共基类的数据或调用一个方法时，不知道是哪一个父类的数据和方法，会导致编译错误。可以采用虚继承的方法解决(父类继承公共基类时用`virtual`修饰)，这样就只会创造一份公共基类的实例，不会造成二义性。

- **一个空的类占多大内存？如果这个类包含了一个虚函数呢，假设是64位的机器？如果有一个类继承了空类，大小是多少？**

  答：空类的大小通常为 1 字节，这是为了保证空类的实例在内存中拥有独立的地址。

  如果类中包含了至少一个虚函数，类的大小会增加，因为类需要存储指向虚表指针。在64位系统上，指针的大小通常是8字节。因此，一个包含虚函数的类的大小至少是8字节，以存储这个指向虚函数表的指针。

  如果有一个类继承了一个空类，派生类的大小取决于它自己的成员以及继承机制。在标准的空基优化下，编译器可以优化空基类所占用的空间。如果派生类本身不包含任何数据成员或虚函数，它可能仍然只占用1字节。但如果派生类添加了数据成员或虚函数，它的大小将增加以容纳这些成员和/或虚函数表指针。然而，如果派生类包含虚函数（即使基类为空），它的大小至少包括虚函数表指针的大小。对于64位系统，通常是8字节。

#### 1.3 内存管理（内存分配、内存对齐）

- **C++是如何做内存管理的（有哪些内存区域）?**

  答：（1）堆，使用`malloc`、`free`动态分配和释放空间，能分配较大的内存；

  ​	（2）栈，为函数的局部变量分配内存，能分配较小的内存；

  ​	（3）全局/静态存储区，用于存储全局变量和静态变量；

  ​	（4）常量存储区，专门用来存放常量；

  ​	（5）自由存储区：通过`new`和`delete`分配和释放空间的内存，具体实现可能是堆或者内存池。

  补充：堆是C和操作系统的术语，自由存储区是C++的术语，指的是通过`new`和`delete`动态分配和释放对象的抽象概念；基本上C++也会用堆区实现自由存储，但程序员可以通过重载操作符，改用其他内存实现自由存储，比如全局变量做的对象池。

- **堆和栈的内存有什么区别？**

  答：（1）堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放；

  ​	（2）堆能分配的内存较大（4G(32位机器)），栈能分配的内存较小（1M）；

  ​	（3）在堆中分配和释放内存会产生内存碎片，栈不会产生内存碎片；

  ​	（4）堆的分配效率低，栈的分配效率高；

  ​	（5）堆地址从低向上，栈由高向下。

- **C++和C分别使用什么来做内存的分配和释放？有什么区别，能否混用？**

  答：C使用`malloc/free`，C++使用`new/delete`，前者是C语言中的库函数，后者是C++语言的运算符，对于自定义对象，`malloc/free`只进行分配内存和释放内存，无法调用其构造函数和析构函数，只有`new/delete`能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间，不能混用，具体区别如下：

  （1）`new`分配内存空间无需指定分配内存大小，`malloc`需要；

  （2）`new`返回类型指针，类型安全，`malloc`返回`void*`，再强制转换成所需要的类型；

  （3）`new`是从自由存储区获得内存，`malloc`从堆中获取内存；

  （4）对于类对象，`new`会调用构造函数和析构函数，`malloc`不会（核心）；

  （5）`malloc`分配内存失败返回空，`new`失败抛异常。

  `new`申请内存的步骤：调用`operator new`函数，分配一块足够大，且原始的，未命名的内存空间来存储特定类型的对象。运行相应的构造函数来构造对象，并为其传入初值，返回一个指向该对象的指针。

  `delete`：先调用对象的析构函数，再调用`operator delete`函数释放内存空间。

- **delete和delete[]的区别，delete[]如何知道要delete多少次？在类的成员函数中能否delete this？**

  答：（1）若是基本类型，`delete`和`delete[]`效果是一样的，因为系统会自动记录分配的空间，然后释放；对于自定义数据类型而言（比如类）就不行了，`delete`仅仅释放数组第一个元素的内存空间，且仅调用了第一个对象的析构函数，但`delete[]`会调用数组所有元素的析构函数，并释放所有内存空间；

  ​	（2）C++会在分配数组空间时多分配4个字节的大小，专门保存数组的维度，这个数据就存在这个分配返回的指针周围，在 `delete[]`时就可以取出这个保存的数，就知道了需要调用析构函数多少次了；

  ​	（3）在类的成员函数可以调用`delete this`，并且`delete this`之后还可以调用该对象的其他成员，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。当一个类对象声明时，系统会为其分配内存空间，在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。

- **什么是内存对齐(字节对齐)，为什么要做内存对齐，如何对齐？**

  答：（1）内存对齐的原因：关键在于CPU存取数据的效率问题。为了提高效率，计算机从内存中取数据是按照一个固定长度的。比如在32位机上，CPU每次都是取32bit数据的，也就是4字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度；

  ​	（2）内容：内存对齐是指数据存储在内存中的起始地址按照一定的规则（通常是某个数的倍数）进行对齐。例如，如果一个类型需要按4字节对齐，那么它的起始地址应该是自身大小与设定对齐值中最小值的整数倍；

  ​	（3）**对齐原则**：结构体第一个元素偏移量为0，此后每个元素的起始地址应该是自身大小与设定对齐值中最小值的整数倍，若没有设置对齐字节数，则最大成员为对齐字节；若设置了对齐字节数 `#pragma pack(n)`，则对齐字节数为 `min(最大成员, 设定的对齐字节数)`的整数倍，如有需要，编译器会在最后一个成员末尾进行填充对齐。

  ​	（4）如何对齐：声明数据结构时，字节对齐的数据依次声明，然后小成员组合在一起，能省去一些浪费的空间，不要把小成员参杂声明在字节对齐的数据之间。

- **如何保证类的对象只能被开辟在堆上？（将构造函数声明为私有、单例）**

  答：将构造函数设置为私有，这样只能使用`new`运算符来建立对象，但是我们必须准备一个`destory`函数来进行内存的释放，提供一个`public`的`static`函数来完成构造，类似于单例模式。
  
  ```cpp
  class HeapOnly {
  private:
    // 私有构造函数阻止了栈上的对象创建
    HeapOnly() {}

  public:
    // 静态方法用于创建对象，并返回对象的指针
    static HeapOnly* createInstance() {
        return new HeapOnly();
    }

    // 确保可以正常删除通过createInstance创建的对象
    void destroy() { delete this; }
  };

  int main() {
      // 试图在栈上创建对象会失败
      // HeapOnly obj; // 错误: 构造函数是私有的

      // 在堆上创建对象
      HeapOnly* obj = HeapOnly::createInstance();

      // 使用对象...

      // 删除堆上的对象
      obj->destroy();
  }
  ```

  **如果在栈上分配呢？** 则是重载`new`操作符，使得`new`操作符的功能为空，这样就使得外层程序无法在堆上分配对象，只可以在栈上分配。

- **为什么会有栈溢出，为什么栈会设置容量？**

  答：栈空间是预设的，它通常用于存放临时变量，如果在函数内部定义一个局部变量，空间超出了设置的栈空间大小，就会溢出。不仅如此，如果函数嵌套太多，也会发生栈溢出，因为函数没有结束前，函数占用的变量也不被释放，占用了栈空间。

  原因：栈的地址空间必须连续，如果任其任意成长，会给内存管理带来困难。对于多线程程序来说，每个线程都必须分配一个栈，因此没办法让默认值太大。 

#### **1.4 类型转换**

- **C++有哪些类型转换的方法(关键字)，各自有什么作用**？

  答：（1）`const_cast`:：把`const`属性去掉，即将`const`转换为`非const`（也可以反过来），`const_cast`只能用于指针或引用，并且只能改变对象的底层`const`（`顶层const`，本身是const，`底层const`，指向的对象是const）；

  ​	（2）`static_cast`： 隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，`enum`、`struct`、 `int`、`char`、`float`等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含`底层const`的对象，能把空指针转换成目标类型的空指针；

  ​	（3）`dynamic_cast`：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回`NULL`，若引用返回失败抛出`bad_cast`异常。`dynamic_cast`是在运行时进行安全性检查。使用`dynamic_cast`父类一定要有虚函数，否则编译不通过；

  ​	（4）`reinterpret_cast`：`reinterpret`是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）。

- **static_cast和dynamic_cast的异同点？**

  答：二者都会做类型安全检查，只是`static_cast`在编译期进行类型检查，`dynamic_cast`在运行期进行类型检查。后者需要父类具备虚函数，而前者不需要。

#### **1.5 智能指针**

- **C++中的智能指针有哪些，各自有什么作用?**

  答：智能指针主要解决内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(`shared_ptr`)，独占指针(unique_ptr)和弱指针(weak_ptr)：

  （1）`shared_ptr`，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；

  （2）`unique_ptr`，保证同一时间段内只有一个智能指针能指向该对象（可通过`move`操作来传递`unique_ptr`）；

  （3）`weak_ptr`，用来解决`shared_ptr`相互引用时的死锁问题，如果说两个`shared_ptr`相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和`shared_ptr`之间可以相互转化，`shared_ptr`可以直接赋值给它，它可以通过调用`lock`函数来获得`shared_ptr`。

- **shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？**

  答：`shared_ptr`是通过引用计数机制实现的，引用计数存储着有几个`shared_ptr`指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；

  **控制块（Control Block）**

  每个 `std::shared_ptr` 都关联一个控制块，这个控制块包含：

  - 引用计数（Reference Count）：追踪有多少个 `shared_ptr` 实例共享同一个资源。
  - 弱引用计数（Weak Count）：追踪有多少个 `std::weak_ptr` 实例与该 `shared_ptr` 关联。`std::weak_ptr` 是一种不增加引用计数的智能指针，用于解决智能指针之间的循环引用问题。
  - 被管理的对象以及可能的自定义删除器或分配器。

  **计数器操作**

  - **构造时**：当你创建一个 `std::shared_ptr` 时，它会初始化引用计数为 1，并创建一个控制块（如果是从原始指针创建的）。
  - **拷贝构造或赋值时**：如果一个 `shared_ptr` 被拷贝构造或赋值给另一个 `shared_ptr`，新的 `shared_ptr` 会指向同一个控制块，并且该控制块的引用计数会增加。
  - **析构或重置时**：当一个 `shared_ptr` 被析构或被重置（指向另一个对象或者 `nullptr`）时，控制块的引用计数会减少。如果引用计数达到 0，意味着没有任何 `shared_ptr` 指向该对象了，此时会调用删除器（默认是 `delete`）来销毁对象，并销毁控制块本身。如果还有 `weak_ptr` 指向对象，控制块会保持存在直到最后一个 `weak_ptr` 也消失。

  **线程安全**

  `std::shared_ptr` 的实现通常是线程安全的，至少在对计数器的修改上是这样。这意味着，从不同线程同时创建或销毁指向同一个对象的 `shared_ptr` 实例是安全的。这通常通过原子操作来实现计数器的增加和减少，确保在多线程环境下的线程安全性。然而，即便 `shared_ptr` 本身是线程安全的，被管理的对象的成员函数不一定是线程安全的，这取决于对象的具体实现。

  ```cpp
  template<typename T>
  class shared_ptr {
  public:
      shared_ptr() = default;
      shared_ptr(T* p = nullptr) : ptr(p), use(new int(1)) {}
      shared_ptr(const shared_ptr& other) 
          : ptr(other.ptr), use(other.use) { (*use)++; }
      shared_ptr& operator=(const shared_ptr& other) {
          if (this != &other) {
              if (--(*use) == 0) {
                  delete use;
                  delete ptr;
              }
              
              ptr = other.ptr;
              use = other.use;
              ++*(use);
          }
          return *this;
      }
      shared_ptr(shared_ptr&& other) {
          ptr = other.ptr;
          use = other.use;
          
          other.ptr = nullptr;
          other.use = nullptr;
      }
      shared_ptr& operator=(shared_ptr&& other) {
          if (this != &other) {
              if (--(*use) == 0) {
                  delete use;
                  delete ptr;
              }
              
              ptr = other.ptr;
              use = other.use;
              
              other.ptr = nullptr;
              other.use = nullptr;
          }
          return *this;
      }
      ~shared_ptr() {
          if (--(*use) == 0) {
              delete use;
              delete ptr;
          }
      }
  private:
      int* use;
      T* ptr;
  };
  ```

- **循环引用**

  答：循环引用发生在两个或多个对象通过 `shared_ptr` 相互引用时，形成一个闭环。这会阻止彼此引用的对象的引用计数降至零，因此这些对象及其资源永远不会被自动释放，导致内存泄漏。`std::weak_ptr` 是一种智能指针，设计用来解决 `std::shared_ptr` 的循环引用问题。`weak_ptr` 持有对对象的非拥有（弱）引用，意味着它不会增加对象的引用计数。这允许你从一个对象安全地引用另一个对象，而不会产生循环引用。

  当你需要访问 `weak_ptr` 指向的对象时，你可以使用 `lock()` 方法尝试获取一个 `std::shared_ptr`。如果那个对象还存在（即，至少有一个 `shared_ptr` 仍然指向它），`lock()` 会成功返回一个有效的 `shared_ptr`。如果对象已经被删除，`lock()` 将返回一个空的 `shared_ptr`。

- **weak_ptr真的不计数？是否有计数方式，在哪分配的空间？**

  答：计数，控制块中有强弱引用计数，如果是使用`make_shared`初始化的函数则它所在的控制块空间是在所引用的`shared_ptr`中同一块的空间，若是`new`则控制器所分配的内存与`shared_ptr`本身所在的空间不在同一块内存。

- **weak_ptr是怎么实现的？**

  答：依赖于计数器和寄存器实现的，计数器用来记录弱引用的数量，寄存器用来存储`shared_ptr`。

- **weak_ptr怎么判断对象是否被销毁，底层怎么实现的？**

  答：**判断对象是否被销毁**：`weak_ptr` 提供了 `expired()` 方法来检查所观察的对象是否已经被销毁。如果所观察的对象已经被销毁（即与之关联的 `std::shared_ptr` 的引用计数已经降到 0），`expired()` 方法返回 true；否则，返回 false。此外，`std::weak_ptr` 还提供了 `lock()` 方法，该方法尝试将 `weak_ptr` 转换为 `std::shared_ptr`。如果所观察的对象仍然存在，`lock()` 方法会返回一个有效的 `std::shared_ptr` 实例；如果对象已经被销毁，则返回一个空的 `std::shared_ptr`。

  **底层实现**：`weak_ptr` 和 `shared_ptr` 都使用一个底层的控制块来管理资源和维护引用计数。这个控制块包含两个重要的计数器：

  - **强引用计数**：追踪有多少个 `shared_ptr` 实例正在管理同一个对象。只有当这个计数降到 0 时，对象才会被销毁。
  - **弱引用计数**：追踪有多少个 `weak_ptr` 实例正在观察同一个对象。这个计数器包括所有 `weak_ptr` 实例以及那些仍然存在的 `shared_ptr` 实例，因为每个 `shared_ptr` 都能被转换成 `weak_ptr`。

  当最后一个指向对象的 `shared_ptr` 被销毁时，对象会被删除，但控制块仍然保留在内存中。这时，强引用计数为 0，但如果还有 `weak_ptr` 指向对象，弱引用计数将大于 0。控制块只有在弱引用计数也降到 0 时才会被销毁，即没有任何 `shared_ptr` 或 `weak_ptr` 指向该对象时。

- **weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw ptr来解决这个问题？**

  答：一个`weak_ptr`绑定到`shared_ptr`之后不会增加引用计数，一旦最后一个指向对象的`shared_ptr`被销毁，对象就会被释放，即使`weak_ptr`指向对象，也还是会释放，控制块记录的弱引用计数确保了，即便管理的对象已经被销毁，只要还有 `weak_ptr` 指向它，控制块本身和其中的元数据（如引用计数）不会被销毁。这个机制防止了悬挂指针和无效访问的发生；`raw`指针，当对象销毁之后会变成悬浮指针。

- **假如类D继承了类B，且析构函数均不是虚函数，那么`shared<B>(new D)`能正确析构吗？**

  答：通过`std::shared_ptr<B>`来管理一个`D`对象的实例可能会导致未定义行为，因为当`std::shared_ptr<B>`的实例被销毁时，它只会调用基类`B`的析构函数，而不会调用派生类`D`的析构函数。这意味着如果派生类`D`有自己的资源需要在析构函数中释放，那么这些资源将不会被正确释放，从而可能导致资源泄露或其他问题。

  为了确保对象的正确析构，至少应该在基类中将析构函数声明为虚函数。这样，当通过基类指针（或智能指针指向基类类型）删除派生类对象时，C++运行时会正确地调用派生类的析构函数，然后是基类的析构函数，从而确保资源的正确释放和对象的正确析构。

- **unique_ptr可以放在标准库的容器中吗？**

  答：可以。因为`std::unique_ptr`不能被复制（只能被移动），所以当想要将它们放入容器或从容器中移除时，需要使用`std::move`来转移所有权。

- **野指针、悬空指针、和内存泄漏是什么？如何避免？**

  答：**内存泄漏**是指程序中动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。避免：使用智能指针管理资源，在释放对象数组时使用delete[]，尽量避免在堆上分配内存；

  **野指针**是指向一个已删除的对象或未申请访问受限内存区域的指针。避免：对指针进行初始化，用已合法的可访问内存地址对指针初始化，指针用完释放内存，将指针赋值`nullptr`；

  **悬空指针**是指向的内存区域被释放，但指针没有及时置空。

- **RAII**

  答：RAII 是 C++ 中的一个重要编程范式，代表资源获取即初始化（Resource Acquisition Is Initialization）。它是一种资源管理技术，用于确保在对象的生命周期中正确管理资源的分配和释放。RAII 基本思想是，资源的获取应该与对象的生命周期相关联，并且资源的释放应该在对象销毁时自动进行，以避免资源泄漏。

  RAII 的核心概念包括以下几点：

  - 资源管理类：创建一个类来管理特定类型的资源（如内存、文件、锁等），这个类的构造函数用于获取资源，析构函数用于释放资源。
  - 构造函数负责资源获取：在资源管理类的构造函数中，资源应该被正确分配和初始化。这可以确保资源在对象创建时可用。
  - 析构函数负责资源释放：在资源管理类的析构函数中，资源应该被释放或关闭。这可以确保在对象销毁时，资源得以释放，无论是正常销毁还是异常情况下。
  - 自动管理：RAII 类的对象通常用栈分配，它们的生命周期由对象的作用域控制。当对象超出作用域时，析构函数会自动被调用，从而释放相关资源。
  - 异常安全：RAII 在面对异常时能够提供良好的异常安全性，因为资源在析构函数中释放，确保在异常发生时资源也能正确释放，从而避免资源泄漏。

#### 1.6 左值右值，构造函数

- **指针和引用的区别**

  答：（1）指针是一个变量，里面存放的是地址，引用只是变量的一个别名；

  ​	（2）指针可以有多级指针，引用只能有一级；

  ​	（3）指针在初始化后可以改变指向，引用一旦初始化就不能改变；

  ​	（4）对指针取地址得到的是指针变量的原地址，对引用取址得到的是变量的地址。

- **数组和指针的区别**

  答：（1）数组是存储多个相同数据类型的集合，数组名是首元素的地址，指针是一个变量，里面存放的是地址

  ​	（2）数组在内存中是连续存储的，通过数组下标进行访问，而指针存储的存储空间不能确定

  ​	（3）用 sizeof 计算数组，得到的是整个数组的大小，而指针得到的是该指针变量的大小

- **什么是左值和右值，什么是右值引用，为什么要引入右值引用？**

  答：（1）左值就是具有可寻址的存储单元，并且能由用户改变其值的量，比如常见的变量：一个int，float，class等。左值具有持久的状态，直到离开作用域才销毁；右值表示即将销毁的临时对象，具有短暂的状态，比如字面值常量5，返回非引用类型的表达式int func()等，都会生成右值；

  ​	（2）右值引用就是必须绑定到右值的引用，可以通过`&&`（两个取地址符）来获得右值引用；右值引用只能绑定到即将销毁的对象，因此可以自由地移动其资源；

  ​	（3）右值引用是为了支持移动操作而引出的一个概念，它只能绑定到一个将要销毁的对象，使用右值引用的移动操作可以避免无谓的拷贝，提高性能。使用`std::move()`函数可以将一个左值转换为右值引用。

- **move底层是怎么实现的？**

  答：move的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义，从实现原理上讲基本等同一个强制类型转换。

  优点：可以将左值变成右值而避免拷贝构造，将对象的状态所有权从一个对象转移到另一个对象，只是转移，没有内存搬迁或者内存拷贝。

- **move和forward有什么区别？**

  答：**用途区别**：`std::move`用于移动语义，总是将其参数转换为右值引用，并且`std::move`不需要指定模板实参，模板实参是由函数调用推导出来的。`std::forward`用于完美转发，在转发过程中保持参数的值类别（左值或右值），且在使用的时候需要指定模板实参。**使用场景**：`std::move`用在需要“移动”一个对象时；`std::forward`用在模板编程中，尤其是当需要完美转发一个参数到另一个函数，同时保持其原始的左值/右值特性时。

- **Lambda表达式auto &&类型推导支持万能引用吗？**

  答：支持。万能引用允许函数模板或者Lambda表达式处理传递给它们的参数，无论是左值还是右值，而不需要编写重载或特化版本。

  ```cpp
  auto lambda = [](auto&& arg) {
      // 在这里可以使用std::forward来完美转发arg
      // 保持其值类别（左值或右值）不变，这对于保持高效性和避免不必要的复制特别重要
  };
  ```

- **引用折叠规则**

  答：万能引用必须是`T&&`或`auto&&`形式。只要有左值引用类型参与最后推导的结果就是左值引用，若实际类型是一个非引用类型或是右值引用类型最后推导出来的就是右值引用。

- **为什么要自己定义拷贝构造函数？什么是深拷贝和浅拷贝？**

  答：拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被`delete`掉，那么另一个类里面的指针就会变成野指针（悬浮指针）；这也正是**深拷贝和浅拷贝的区别**，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

- **什么是移动构造函数，和拷贝构造函数的区别？**

  答：移动构造函数需要传递的参数是一个右值引用，移动构造函数不分配新内存，而是接管传递而来对象的内存，并在移动之后把源对象销毁；拷贝构造函数需要传递一个左值引用，可能会造成重新分配内存，性能变低。

- **实现一个模板类，写出它的拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数**

  ```cpp
  template<typename T>
  class SimpleArray {
  public:
      // 构造函数
      explicit SimpleArray(std::size_t size) 
          : size_(size), data_(new T[size]) {}
  
      // 拷贝构造函数
      SimpleArray(const SimpleArray& other) 
          : size_(other.size_), data_(new T[other.size_]) {
          std::copy(other.data_, other.data_ + other.size_, data_);
      }
  
      // 拷贝赋值运算符
      SimpleArray& operator=(const SimpleArray& other) {
          if (this != &other) {
              // 释放旧资源
              delete[] data_;
  
              size_ = other.size_;
              data_ = new T[size_];
              std::copy(other.data_, other.data_ + size_, data_);
          }
          return *this;
      }
  
      // 移动构造函数
      SimpleArray(SimpleArray&& other) noexcept 
          : size_(other.size_), data_(other.data_) {
          other.size_ = 0;
          other.data_ = nullptr;
      }
  
      // 移动赋值运算符
      SimpleArray& operator=(SimpleArray&& other) noexcept {
          if (this != &other) {
              // 释放旧资源
              delete[] data_;
  
              size_ = other.size_;
              data_ = other.data_;
              other.size_ = 0;
              other.data_ = nullptr;
          }
          return *this;
      }
  
      // 析构函数
      ~SimpleArray() {
          delete[] data_;
      }
  
  private:
      std::size_t size_;
      T* data_;
  };
  
  ```

- **为什么移动操作要标记为 noexcept？**

  答：移动构造函数和移动赋值运算符被标记为 `noexcept` 是出于性能优化的考虑。`noexcept` 指示这些操作不会抛出任何异常。

  **为什么移动操作标记为 `noexcept` 很重要：**

  1. **异常安全性**：通过保证移动操作不抛出异常，我们可以确保即使在复杂操作中（如重新分配内存时移动元素到新位置），也能保持程序的异常安全性和稳定性。
  2. **性能优化**：当容器（如 `std::vector`）需要调整大小或进行元素重排时，如果其元素的移动构造函数和移动赋值运算符被标记为 `noexcept`，容器会优先选择移动操作而非拷贝操作。这是因为移动操作通常更快，并且不涉及实际的数据复制。如果移动操作可能抛出异常，容器为了保证异常安全，可能会选择使用拷贝操作代替，因为拷贝操作在抛出异常时通常能更安全地回滚状态。
  3. **优化选择**：在某些情况下，标准库中的某些函数和容器会根据类型是否承诺不抛出异常（即是否为 `noexcept`）来选择最优的重载或行为策略。标记为 `noexcept` 的移动操作使得这些类型对于容器和算法更加友好，从而提升整体性能和效率。

  **示例**

  考虑 `std::vector` 的 `push_back` 和 `emplace_back` 操作，当它们导致容器重新分配内存时：

  - 如果元素类型的移动构造函数被标记为 `noexcept`，`std::vector` 可以安全地移动元素到新分配的内存，即使中途出现异常也不会破坏数据完整性。
  - 如果移动构造函数可能抛出异常（即没有被标记为 `noexcept`），那么在重新分配内存并移动元素时，`std::vector` 可能不得不采取更保守的策略，如使用拷贝构造函数，以避免潜在的异常导致的问题。这不仅降低了性能，还增加了额外的要求，即元素类型必须是可拷贝的。

  因此，除非确实有抛出异常的可能，否则应该尽可能地为移动构造函数和移动赋值运算符添加 `noexcept` 说明符，以提升代码的性能和使用灵活性。

- **成员变量初始化的顺序是什么？**

  答：成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。类中const成员常量必须在构造函数初始化列表中初始化。类中static成员变量，只能在类外初始化。

  **顺序**：基类的静态变量或全局变量，派生类的静态变量或者全局变量，基类的成员变量，派生类的成员变量。

- **什么是this指针，为什么存在this指针？**

  答：类和对象中的成员函数存储在公共的代码段，不同的对象调用成员函数时编译器为了知道具体操作的是哪一个对象，给每个“非静态成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过这个指针来完成的，由编译器自动完成。

#### 1.7 各种关键字

- **`struct` 和 `class`** 的区别

  1. struct 一般用于描述一个数据结构集合，class 是对一个对象数据的封装
  2. class 默认访问修饰符是 private，struct 是 public
  3. class 默认是私有继承，struct 默认是公有继承

- **`const`的四种作用**

  1. const 修饰局部变量或全局变量，初始化后不能更改
  2. const 修饰函数的参数，为了避免该参数被修改
  3. const 修饰函数返回值，说明函数的返回类型是 const 的，则返回值不能被修改
  4. const 修饰类的方法，则不能修改其成员变量的值

- **常量指针和指针常量的区别**

  1. 常量指针：写做 `int* const p`，指针本身是一个常量，它的值不能修改。顶层 const（自身是常量）
  2. 指针常量：写做 `int const *p`，指针所指是一个常量，它的指向不能修改。底层 const（指向的对象是常量）

- **迭代器和指针的区别**

  答：迭代器不是指针，是一个模板类，通过重载了指针的一些操作符模拟了指针的一些功能，迭代器返回的是对象引用而不是对象的值。指针能够指向函数而迭代器不行迭代器只能指向容器。

- **`const`修饰的函数能否重载？**

  答：可以重载。const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；const类对象只能调用const成员函数，非const对象无论是否是const成员函数都能调用，但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。

- **`static` 的作用**

  1. 第一个作用是隐藏，不加 static 的全局变量和函数具有全局可见性，可以在其他文件中使用，而加了之后，只能在该文件所在的编译模块中使用
  2. 作用在局部变量上，可以提高其生命周期。它不会出代码块而销毁，而是存储在静态存储区中
  3. static 修饰成员变量或者成员函数，它就只与类进行关联，而不再属于栈上某个对象的数据，所有对象都共享这一块静态存储空间
  4. static变量在类的声明中不占用内存，因此必须在.cpp文件中定义类静态变量以分配内存。全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量在第一次使用时分配内存并初始化

- **静态变量在哪里初始化？在哪一个阶段初始化？（都存放在全局区域）**

  答：（1）**全局静态变量** 的内存分配发生在编译时期，作为程序的数据段的一部分。它们的初始化在程序开始执行、进入main函数之前完成。（全局变量/全局常量相同）
  
  （2）**函数内的局部静态变量** 的内存分配在编译时期完成，但它们的初始化是在该变量第一次被执行到时进行的，这种方式称为“延迟初始化”或“懒惰初始化”，确保了只有在实际需要时才进行初始化。

  （3）**类的静态成员变量** 也是在编译时期分配内存，通常位于程序的数据段。对于基本数据类型的静态成员，如果有初始值，它们会在程序启动时（进入main之前）被初始化，这一点与全局静态变量相似。如果是类类型的静态成员变量，则它们的初始化时机依赖于具体的实现，但通常也是在第一次访问之前完成。

- **全局静态变量和全局非静态变量的初始化顺序**

  答：无特定顺序，先定义则先初始化。

- **`define` 宏定义 和 `const` 的区别**

  1. 宏定义是在编译的 **预处理阶段** 起作用，const 是在编译、运行阶段起作用
  2. 宏定义 **只做替换不会进行检查**，const **有数据类型编译器会对它进行类型检查**
  3. 宏定义的数据 **没有分配内存** ，只是 **插入替换**，**const 定义的变量只是值不能变，** 但是 **会分配内存**

- **`define` 宏定义 和 `inline` 内联函数的区别**

  1. 宏定义在 **预处理阶段** 起作用，只做简单的字符串替换没有返回值，内联函数在 **编译** 阶段起作用，**有返回值**
  2. 内联函数在 **编译** 时直接将 **函数代码嵌入到目标代码中** ，省去了函数调用的开销，从而提高性能，并且可以重载
  3. 编译器会对内联函数进行类型检查以及语法判断，而宏定义不会

- **`explicit`用在哪里？有什么作用？**

  答：只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显式的，而非隐式的，跟它对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。explicit作用是防止类构造函数的隐式自动转换。

- **`constexpr`的作用？**

  答：这个关键字明确的告诉编译器应该去验证(函数或变量)在编译期是否就应该是一个常数（这样编译器就可以大胆进行优化）。

- **`volatile`的作用？**

  答：跟编译器优化有关，告诉编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的备份。

- **`mutable`的作用？**

  答：可变的意思，使类中被声明为const的函数可以修改类中的非静态成员。

- **`extern`的作用?**

  答：当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按照C的规则去翻译相应的函数名而不是C++的；当它作为一个对函数或者全局变量的外部声明，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。

- **`final`标识符的作用是什么？**

  答：放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载。

- **`auto`是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？**

  答：auto仅仅只是一个占位符，在编译期间它会被真正的类型替代，或者说C++中变量必须要有明确类型的，只是这个类型是由编译器自己推导出来的。函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式具体类型函数的模具，所以模板其实就是将原本应该我们做重复的事情交给了编译器。

- **`auto`和`deltype`的作用和区别？**

  答：用于实现类型自动推导，让编译器来操心变量的类型；auto不能用于函数传参和推导数组类型，但deltype可以解决这个问题。

- **`make_shared`函数的优缺点？**

  答：优点：减少了内存分配的次数，降低了系统开销，提高了效率，使用new构造的话至少会进行两次内存分配，（一次为智能指针本身，一次为共享指针的控制块）；

  缺点：当构造函数是保护或者私有的时候无法使用make_shared函数；会导致weak_ptr保持控制块的生命周期，连带着保持了对象分配的内存，只有当最后一个weakptr离开作用域时，内存才会被释放，对于内存要求高的场景来说，是一个需要注意的问题。

#### 1.8 杂项

- **重载、重写和隐藏的区别**

  答：**重载** 指的是同一个名字的函数，具有不同的参数列表（参数类型、个数），或不同的返回类型，根据参数列表和返回类型决定调用哪一个函数；**重写（覆盖）** 指的是，派生类中的函数重写了基类中的虚函数，重写的基类的中函数必须被声明为virtual，并且返回值，参数列表和基类中的函数一致；**隐藏，** 是指派生类中的同名函数把基类中的同名函数隐藏了，即基类同名函数被屏蔽掉，此时基类函数不能声明为virtual。

- **`i++` 和 `++i` 的区别**

  答：`i++` 是先加后赋值，返回一个对象；而 `++i` 是先赋值后加，返回一个引用。临时对象会导致效率降低。所以 `++i` 更快。

- **类的默认成员函数**

  1. 无参的构造函数：用于完成对象的初始化工作
  2. 拷贝构造函数：用于复制本类对象
  3. 赋值运算符重载函数：同样也是负责本类的对象
  4. 析构函数：用于对象的清理

- **`lamda`表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？**

  答：按值捕获和引用捕获，默认的引用捕获可能会导致悬挂引用，引用捕获会导致闭包包含一个局部变量的引用或者形参的引用，如果一个由lambda创建的闭包的生命周期超过了局部变量或者形参的生命期，那么闭包的引用将会空悬。解决方法是对个别参数使用值捕获。

- **C++哪些运算符不能被重载？**

  答：成员访问操作符，域解析操作符，条件运算符之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。

- **讲一讲迭代器失效及其解决方法**

  答：**序列式容器迭代器失效**：当当前元素的迭代器被删除后，后面所有元素的迭代器都会失效，他们都是一块连续存储的空间，所以当使用erase函数操作时，其后的每一个元素都会向前移动一个位置，此时可以使用erase函数操作可以返回下一个有效的迭代器。

  **vector迭代器失效问题总结**：

  1. 当执行了erase方法时，指向删除节点的迭代器全部失效，指向删除节点之后的全部迭代器也失效
  2. 当进行push_back方法时，end操作返回的迭代器肯定失效
  3. 当插入一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器失效
  4. 当插入一个元素后，如果空间未重新分配，指向插入位置之前的元素的迭代器依然有效，但指向插入元素之后元素的迭代器全部失效

  **deque迭代器失效总结**：

  1. 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效，如果在首尾位置添加元素，迭代器会失效，但是指针和引用不会失效
  2. 如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器都会失效
  3. 如果在其首部和尾部删除元素则只会使指向被删除元素的迭代器失效

  **关联型容器迭代器失效**：

  1. 删除当前的迭代器，仅仅会使当前的迭代器失效，只要erase时，递增当前迭代器即可

- **回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？**

  答：回调函数是指使用者自己定义一个函数，实现这个函数的程序内容，然后别人把这个函数（入口地址）作为参数传入别人的函数中，由别人的函数在运行时来调用的函数，简单说就是放发生某种事件时，系统或其他函数将会自动调用你定义的一段函数。

  可以把调用者和被调用者分开。调用者不关心谁是被调用者，所以它只需要知道的，只是一个存在某种特定类型原型，某些限制条件的被调用函数。

  优点：

  ​		可以让实现方根据回调方的多种形态进行不同的处理和操作

  ​		可以让实现方，根据自己的需要定制回调方的不同形态

  ​		可以将耗时的操作隐藏在回调方，不影响实现方其他信息的展示。

  ​		让代码的逻辑更加集中，更加易读。

  缺点：

  ​		回调函数过多会导致代码难以维护

  ​		回调函数容易造成资源竞争：如果回调函数中有共享资源访问，容易出现资源争抢，导致程序出错

  ​		代码可读性差，可能会破坏代码的结构和可读性

  本质：

  ​		是将函数当作参数使用，目的是为了使程序更加普适。

- **C++中多线程是什么？和单线程的比较有哪些优缺点？是否存在不如单线程的情况？为什么以及什么情况不如？**

  答：多线程是指程序在同一时间执行多个线程以提高执行效率和响应速度的能力。在C++11之后，多线程编程成为了语言标准的一部分，通过 `<thread>`、`<mutex>`、`<future>`、`<atomic>` 等头文件提供支持。多线程允许任务并行处理，从而在多核处理器上显著提高应用程序的性能。

  与单线程的比较

  ​	优点：

  1. **性能提升**：在多核处理器上，多线程可以并行执行多个任务，减少程序总体的执行时间。
  2. **资源利用率提高**：可以更有效地使用CPU资源，同时进行I/O操作和计算任务，减少等待时间。
  3. **响应性提高**：在GUI（图形用户界面）应用程序中，一个线程可以用于维持用户界面的响应，而其他线程执行后台任务，避免界面冻结。

  ​    缺点：

  1. **复杂性增加**：多线程程序的设计和调试比单线程程序复杂得多，需要处理线程之间的同步和数据共享问题。
  2. **资源消耗**：线程的创建和上下文切换需要消耗系统资源，特别是当线程数量非常多时，这种消耗变得更加明显。
  3. **竞态条件和死锁**：不恰当的线程同步可能导致竞态条件、死锁或数据不一致性问题。

  **不如单线程的情况**

  多线程并不总是比单线程执行得更快或更高效。存在一些情况下，多线程可能不如单线程：

  1. **任务主要是CPU密集型且核心已饱和**：如果CPU的所有核心都已经在忙于执行其他任务，那么添加更多的线程只会增加上下文切换的开销，从而降低性能。
  2. **高度同步的任务**：如果多个线程需要频繁地访问和修改共享数据，那么同步开销（比如锁）可能会导致多线程比单线程更慢。
  3. **线程创建和管理的开销**：如果任务非常简短，线程的创建和销毁所需的时间可能比任务本身还要长。
  4. **资源竞争导致的性能瓶颈**：当多个线程争抢有限的系统资源（例如I/O，内存带宽等）时，可能会导致整体性能下降。

- **二叉树前中后非递归遍历**

  前序

  ```cpp
  vector<int> preorderTraversal(TreeNode* root) {
      if (root == nullptr) return {};
  
      stack<TreeNode*> s;
      vector<int> res;
  
      TreeNode* node = root;
      while (node || !s.empty()) {
          if (node) {
              res.push_back(node->val);
              s.push(node);
              node = node->left;
          } else {
              node = s.top();
              s.pop();
              node = node->right;
          }
      }
  
      return res;
  }
  ```

  中序

  ```cpp
  vector<int> inorderTraversal(TreeNode* root) {
      if (root == nullptr) return {};
  
      stack<TreeNode*> s;
      vector<int> res;
  
      TreeNode* node = root;
      while (node || !s.empty()) {
          if (node) {
              s.push(node);
              node = node->left;
          } else {
              node = s.top();
              s.pop();
              res.push_back(node->val);
              node = node->right;
          }
      }
  
      return res;
  }
  ```

  后序

  ```cpp
  vector<int> inorderTraversal(TreeNode* root) {
      if (root == nullptr) return {};
  
      stack<TreeNode*> s;
      vector<int> res;
  
      TreeNode* node = root;
      TreeNode* pre = nullptr;
      while (node || !s.empty()) {
          if (node) {
              s.push(node);
              node = node->left;
          } else {
              node = s.top();
              // 当前节点无右孩子或右孩子已被访问过
              if (node->right == nullptr || pre == node->right) {
                  res.push_back(node->val);
                  pre = node;
                  node = nullptr;
              } else {
                  s.push(node);
                  node = node->right;
              }
          }
      }
  
      return res;
  }
  ```

- **写一个单例模式**

  懒汉式：

  ```cpp
  class SingletonLazy {
  public:
      // 提供一个获取单例对象的静态方法
      static SingletonLazy& getInstance() {
          if (instance == nullptr) {
              instance = new SingletonLazy();
          }
          return *instance;
      }
  
      // 删除拷贝构造函数和拷贝赋值操作符，防止复制
      SingletonLazy(const SingletonLazy&) = delete;
      SingletonLazy& operator=(const SingletonLazy&) = delete;
  
  private:
      // 私有构造函数，防止外部创建实例
      SingletonLazy() {}
  
  private:
      static SingletonLazy* instance;
  };
  
  // 初始化静态成员变量
  SingletonLazy* SingletonLazy::instance = nullptr;
  
  // 使用示例
  SingletonLazy& singleton = SingletonLazy::getInstance();
  ```

  饿汉式：

  ```cpp
  class SingletonEager {
  public:
      // 提供一个获取单例对象的静态方法
      static SingletonEager& getInstance() {
          static SingletonEager instance;
          return instance;
      }
  
      // 删除拷贝构造函数和拷贝赋值操作符，防止复制
      SingletonEager(const SingletonEager&) = delete;
      SingletonEager& operator=(const SingletonEager&) = delete;
  
  private:
      // 私有构造函数，防止外部创建实例
      SingletonEager() {}
  };
  
  SingletonEager& singleton = SingletonEager::getInstance();
  ```

**1.8 其它**

- **int 32位全一是什么值，全一再加一呢？**

  答：对于有符号32位整数（signed int），二进制表示中的最高位用于表示符号，其中0代表正数，1代表负数。因此，当所有32位都为1时，它表示的是有符号整数中的一个负数。有符号整数使用补码表示法来表示负数。在这种表示法中，一个数的补码是将其所有位取反然后加一。所以，全一的32位二进制数实际上是-1，因为它是0的补码。如果对这个数（即-1）再加一，结果将是0，因为-1加1等于0。这就是有符号32位整数全一再加一的结果。

- **如果一个int指针赋给一个double指针，double的地址是什么？**

  答：如果尝试将一个`int`指针赋值给一个`double`指针，实际上是在进行类型不匹配的指针赋值。这种操作通常会引发编译时错误或警告，因为`int`和`double`类型在内存中的表示和大小不同，直接赋值可能会导致未定义的行为。可以强制转换，这样`double_ptr`将指向`int_ptr`指向的地址。换句话说，`double_ptr`和`int_ptr`将有相同的地址值，但是`double_ptr`会将这个地址处的内容解释为`double`类型。但由于`double`和`int`的大小和解释方式通常不同（例如，在许多环境中`int`是4字节，而`double`是8字节），试图通过`double_ptr`访问或修改数据可能会导致未定义行为，比如访问无效的内存区域或者错误地解释数据。


### STL

#### 2.1 STL各种容器的底层实现？

1. **vector**，底层是一块具有连续内存的数组，vector的核心在于其长度自动可变。vector的数据结构主要由三个迭代器(指针)来完成：指向首元素的start，指向尾后的end和指向内存末端的end_of_storage。vector的扩容机制是：当目前可用的空间不足时（当前容器内元素数量的大小size和容器最大大小capacity进行比较如果二者相等），分配目前空间的两倍或者目前空间加上所需的新空间大小（取较大值），容量的扩张必须经过“重新配置、元素移动、释放原空间”等过程。
2. **list**，底层是一个双向循环链表，链表结点和链表分开独立定义的，结点包含pre、next指针和data数据。
3. **deque**，双向队列，由分段连续空间构成，每段连续空间是一个缓冲区（块），由一个中控器来控制。它必须维护一个map指针（中控器指针），用于存储指向各个块的指针，还要维护start和end两个指针，分别指向首个连续空间和最后一个连续空间。deque可以在前端或后端进行扩容，这些指针和迭代器用来控制分段缓冲区之间的跳转。
4. **stack和queue**，栈和队列。它们都是由deque作为底层容器实现的，是一种容器适配器，修改了deque的接口，具有自己独特的性质（此二者也可以用list作为底层实现）；stack是deque封住了头端的开口，先进后出，queue是deque封住了尾端的开口，先进先出。
5. **priority_queue**，优先队列。是由以vector作为底层容器，以heap作为处理规则，heap的本质是一个完全二叉树。
6. **set和map**，底层都是由红黑树实现的。红黑树是一种二叉搜索树，但是它多了一个颜色的属性。红黑树的性质如下：1）每个结点非红即黑；2）根节点是黑的；3）如果一个结点是红色的，那么它的子节点就是黑色的；4）任一结点到树尾端（NULL）的路径上含有的黑色结点个数必须相同。通过以上定义的限制，红黑树确保没有一条路径会比其他路径多出两倍以上；因此，红黑树是一种弱平衡二叉树，相对于严格要求平衡的平衡二叉树来说，它的旋转次数少，所以对于插入、删除操作较多的情况下，通常使用红黑树。

#### **2.2 STL各种容器的查找、删除和插入的时间复杂度（性能比较）？**

1. vector，vector支持随机访问（通过下标），时间复杂度是O(1)；如果是无序vector查找的时间复杂度是O(n)，如果是有序vector，采用二分查找则是O(log n)；对于插入操作，在尾部插入最快，中部次之，头部最慢，删除同理。vector占用的内存较大，由于二倍扩容机制可能会导致内存的浪费，内存不足时扩容的拷贝也会造成较大性能开销；
2. list由于底层是链表，不支持随机访问，只能通过扫描的方式查找，复杂度为O(n)，但是插入和删除的速度快，只需要调整指针的指向。list不会造成内存的浪费，占用内存较小；
3. deque支持随机访问，但性能比vector要低；支持双端扩容，因此在头部和尾部插入和删除元素很快，为O(1)，但是在中间插入和删除元素很慢；
4. set和map，底层基于红黑树实现，增删查改的时间复杂度近似O(log n)，红黑树又是基于链表实现，因此占用内存较小，空间占用相比unordered_set和unordered_map较高；
5. unordered_set和unordered_map，底层是基于哈希表实现的，是无序的。理论上增删查改的时间复杂度是O(1)（最差时间复杂度O(n)），实际上数据的分布是否均匀会极大影响容器的性能，哈希表建立比较耗费时间。
6. priority_queue 支持常数时间的最大元素查找，O(log n) 的插入，O(log n) 的删除最大元素，O(n) 的空间复杂度。
    - 插入（push）：新元素被添加到堆的末尾，即作为最后一个叶子节点。然后，通过比较该元素与其父节点的值，并根据需要进行交换，以保持堆的特性。这个过程被称为上浮或上滤。
    - 删除最大元素（pop）：优先队列中的最大元素总是位于堆的根部。在删除根元素后，通常将最后一个元素移动到根部，然后通过比较该元素与其子节点的值，并根据需要进行交换，以保持堆的特性。这个过程被称为下沉或下滤。
    - 查找最大元素（top）：直接返回堆的根元素，这是一个常数时间的操作，因为根元素直接对应于优先队列中的最大值。

- **push_back()左值和右值的区别是什么？**

  答：参数是左值，则使用它拷贝构造新对象，如果是右值，则使用它移动构造新对象。

- **vector中的push_back()和emplace_back()的区别、以及使用场景**

  答：当使用push_back时会先调用类的有参构造函数创建一个临时变量，再将这个对象拷贝或者移动到容器之中，而emplace_back则是直接在容器尾部进行构造，比push_back少进行一次构造函数调用。在大部分场景中emplace_back可以替换push_back，但是push_back会比emplace_back更加安全，emplace_back只能用于直接在容器中构造新元素的情况，如果要将现有的对象添加到容器中则需要使用push_back。

- **vector扩容，resize和reserve的区别**

  答：`reserve(new_cap)`增加 vector 的容量（capacity，即 vector 在不重新分配存储的情况下能最多能持有的元素的数量）到大于或等于 new_cap 的值。如果 new_cap 大于当前的 capacity()，那么就会分配新存储，否则该方法不做任何事。**reserve() 不会更改 vector 的大小**。如果 new_cap 大于 capacity()，那么所有迭代器，包括 end() 迭代器和所有到元素的引用都会失效。否则，没有迭代器或引用会失效。在调用 reserve() 后，插入只会在它将导致 vector 的大小大于 capacity() 的值时触发重新分配；**resize(count, value)重设容器大小以容纳 count 个元素**，在 count == size() 时不做任何事。如果当前大小大于 count，那么减小容器到它的前 count 个元素。

  如果当前大小小于 count，

  1) 追加额外的默认插入的元素
  2) 追加额外的 value 的副本

- **vector扩容为了避免重复扩容做了哪些机制？**

  答：当vector内存不够时本身内存会以1.5或者2倍的增长，为了减少扩容次数引入了reverse，自定义vector最大容量。

- **vector如何手动释放内存？**

  答：比如有一个vector<int>nums， 比较hack的一种方式是nums = {}，这样既可以清空元素还会释放内存（从一个大佬身上学来的）；规范的做法是，vector<int>().swap(nums)或者nums.swap(vector<int> ())。

- **什么是哈希表？哈希表的长度为什么要是质数？如何处理冲突？哈希表怎么删除一个元素？**

  答：（1）哈希表是一种根据key直接访问value的数据结构，它通过把key映射到表中的一个位置来访问元素，以加快查找的速度。这个映射函数叫做哈希函数；

  ​	（2）哈希表的长度使用质数，可以降低发生冲突的概率，使哈希后的数据更加均匀，如果使用合数，可能会导致很多数据集中分布到一个点上，造成冲突；

  ​	（3）解决冲突的办法有开放定址法和拉链法，开放定址法包括线性测探、平方测探法；

  ​	（4）线性测探法并不会真正的删除一个元素，而是做一个标记，否则可能会导致正常的查找出错。

- **哈希碰撞的处理方法**

  答：（1）开放定址法：当遇到哈希冲突时，去寻找一个新的空闲的哈希地址；

  ​	（2）再哈希法：同时构造多个哈希函数，等发生哈希冲突时就使用其他哈希函数直到不发生冲突为止，虽然不易发生聚集，但是增加了计算时间；

  ​	（3）链地址法：将所有的哈希地址相同的记录都链接在同一链表中；

  ​	（4）建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中。

- **unordered_map的扩容过程**

  答：`unordered_map` 创建时的容量通常由实现定义，但可以通过构造函数指定一个最小容量或负载因子（即元素数量与桶数量的比值）来影响初始容量的选择。当 `unordered_map` 中的元素数量超过当前容量与负载因子（load factor）的乘积时，容器会进行扩容操作，即分配一个更大的内部哈希表并重新计算所有元素的哈希值，将它们插入到新的表中。这个过程称为“rehashing”。通常会按照原有桶的数量 * 2的方式进行扩容，但是具体的增长策略也可以通过修改容器中的max_load_factor成员变量来进行调整；最后，更新`unordered_map`的状态，包括负载因子和桶数量，以反映扩容后的新状态。

- **map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别**

  答：都是红黑树，find查找需要判断返回的结果才知道有没有查询成功。[]不管有没有就是0，如果原先不存在该key，则插入，如果存在则覆盖插入，at方法则会进行越界检查，这会损失性能，如果存在则返回它的值，如果不存在则抛出异常。

#### 2.3 STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？

1. 为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器，直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放。当分配的空间大小小于128B时，将使用第二级空间配置器，采用了内存池技术，通过空闲链表来管理内存。
2. 次级配置器的内存池管理技术：每次配置一大块内存，并维护对应的自由链表(free list)。若下次再有相同大小的内存配置，就直接从自由链表中拔出。如果客户端释还小额区块，就由配置器回收到自由链表中；配置器共要维护16个自由链表，存放在一个数组里，分别管理大小为8-128B不等的内存块。分配空间的时候，首先根据所需空间的大小（调整为8B的倍数）找到对应的自由链表中相应大小的链表，并从链表中拔出第一个可用的区块；回收的时候也是一样的步骤，先找到对应的自由链表，并插到第一个区块的位置。
3. 优势：避免内存碎片(这里应该指的是外部碎片)，不需要频繁从用户态切换到内核态，性能高效；劣势：仍然会造成一定的内存浪费，比如申请120B就必须分配128B（内部碎片）。

#### 2.4 STL的排序用到了哪种算法，具体如何执行？

答：快速排序、插入排序和堆排序；当数据量很大的时候用快排，划分区段比较小的时候用插入排序，当划分有导致最坏情况的倾向的时候使用堆排序。

#### 2.5 各种排序算法的原理和时间复杂度？

1. **快排**：一轮划分，选择一个基准值，小于该基准值的元素放到左边，大于的放在右边，此时该基准值在整个序列中的位置就确定了，接着递归地对左边子序列和右边子序列进行划分。时间复杂度O(nlogn)，最坏的时间复杂度是O(n2)，**不是稳定算法**；

   ```cpp
   int partition(vector<int>& nums, int low, int high) {
       int base = nums[low];
       while (low < high) {
           while (low < high && nums[high] >= base) --high;
           nums[low] = nums[high];
           while (low < high && nums[low] <= base) ++low;
           nums[high] = nums[low];
       }
       nums[low] = base;
       
       return low;
   }
   void sort(vector<int>& nums, int low, int high) {
       if (low >= high) return;
       // 通过交换元素构建分界点 p
       int p = partition(nums, low, high);
   
       sort(nums, low, p - 1);
       sort(nums, p + 1, high);
   }
   ```
稳定的快排：
```cpp
   int partition(vector<int>& nums, int low, int high) {
       int base = nums[low];
       vector<int> left, right; // 分别存放小于和大于等于基准值的元素
       int equalCount = 1; // 记录与基准值相等的元素个数
       for (int i = low + 1; i <= high; ++i) {
           if (nums[i] < base)
               left.push_back(nums[i]);
           else if (nums[i] > base)
               right.push_back(nums[i]);
           else
               equalCount++; // 相等元素暂时不放入左右两侧
       }

       int index = low;
       // 将左侧元素放回原数组
       for (int num : left)
           nums[index++] = num; 
       // 将相等元素放回原数组
       for (int i = 0; i < equalCount; ++i)
           nums[index++] = base; 
       // 将右侧元素放回原数组
       for (int num : right)
           nums[index++] = num; 

       return low + left.size();
   }
   void sort(vector<int>& nums, int low, int high) {
       if (low >= high) return;
       // 通过交换元素构建分界点 p
       int p = partition(nums, low, high);
   
       sort(nums, low, p - 1);
       sort(nums, p + 1, high);
   }
```

2. 堆排序：利用完全二叉树性质构造的一个一维数组，用数组下标代表结点，则一个结点的左孩子下标为2i+1,右孩子为2i+2，一个结点的父节点为(i-1)/2。堆排序的思想就是，构造一个最大堆或者最小堆，以最大堆为例，那么最大的值就是根节点，把这个最大值和最后一个结点交换，然后在从前n-1个结点中构造一个最大堆，再重复上述的操作，即每次将现有序列的最大值放在现有数组的最后一位，最后就会形成一个有序数组；求升序用最大堆，降序用最小堆。时间复杂度O(nlogn)，**不稳定**；

3. 冒泡排序：从前往后两两比较，逆序则交换，不断重复直到有序；时间复杂度O(n2)，最好情况O(n)，**稳定**；

   ```cpp
   vector<int> sortArray(vector<int>& nums) {
       int n = nums.size();
       for (int i = 0; i < n - 1; ++i) {
           for (int j = n - 1; j > i; --j) {
               if (nums[j] < nums[j - 1]) {
                   swap(nums[j - 1], nums[j]);
               }
           }
       }
       
       return nums;
   }
   ```

4. 插入排序，类似打牌，从第二个元素开始，把每个元素插入前面有序的序列中；时间复杂度O(n2)，最好情况O(n)，**稳定**；

   ```cpp
   vector<int> sortArray(vector<int>& nums) {
       int n = nums.size();
       for (int i = 1; i < n; i++) {
           int flag = nums[i];
           int j = i - 1;
           while (j >= 0 && flag < nums[j]) {
               nums[j + 1] = nums[j];
               j--;
           }
           nums[j + 1] = flag;
       }
       
       return nums;
   }
   ```

5. 选择排序，每次选择待排序列中的最小值和未排序列中的首元素交换；时间复杂度O(n2)，**不稳定**；

   ```cpp
   vector<int> sortArray(vector<int>& nums) {
       int n = nums.size();
       for (int i = 0; i < n - 1; i++) {
           int min = i;
           for (int j = i + 1; j < n; j++) {
               if (nums[min] > nums[j])
                   min = j;
           }
           
           if (min != i)
               swap(nums[i], nums[min]);
       }
       return nums;
   }
   ```

6. 归并排序，将整个序列划分成最小的>=2的等长序列，排序后再合并，再排序再合并，最后合成一个完整序列。时间复杂度O(nlogn)，**稳定**。

   ```cpp
   void merge(vector<int>& nums, int low, int mid, int high) {
       int i = low, j = mid + 1, k = low;
       vector<int> tmp(nums.size());
       // 将较小的合并到临时数组
       while (i <= mid && j <= high) {
           if (nums[i] <= nums[j]) tmp[k++] = nums[i++];
           else tmp[k++] = nums[j++];
       }
       // 将左右可能剩余的元素合并
       while (i <= mid) tmp[k++] = nums[i++];
       while (j <= high) tmp[k++] = nums[j++];
       // 将合并完成的数组赋给原待排序数组
       for (i = low; i <= high; ++i) {
           nums[i] = tmp[i];
       }
   }
   void sort(vector<int>& nums, int low, int high) {
       // 终止条件
       if (low >= high) return;
       
       int mid = (low + high) / 2;
       // 对 nums[lo..mid] 进行排序
       sort(nums, low, mid);
       // 对 nums[mid+1..hi] 进行排序
       sort(nums, mid + 1, high);
   
       /****** 在后序位置进行归并操作 ******/
       // 合并 nums[lo..mid] 和 nums[mid+1..hi]
       merge(nums, low, mid, high);
   }
   ```

7. 希尔排序，是插入排序的改进版，取一个步长划分为多个子序列进行排序，再合并(如135一个序列，246一个序列)，时间复杂度O(n1.3)，最好O(n)，最坏O(n2)，**不稳定**；

8. 桶排序，将数组分到有限数量的桶里。每个桶再个别排序，最后依次把各个桶中的记录列出来记得到有序序列。桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)，M为桶的数量。最好的情况下为O(N)，**稳定**。

- **如何在一个序列中求前k个最大或者最小的数？**

  答：（1）基于快排，每轮划分选择一个基准值，把比它小的数放在左边，大的放在右边，函数返回基准值的位置，如果该位置恰好是K，就说明了这是第K小的数，所以从0-基准值位置的数是序列中的前K小数。若返回基准值的位置小于或者大于K，再进行相应调整：如果返回的基准值大于K，在基准值左边序列查找，如果小于，在基准值右边进行查找。递归地进行快排，直到返回的结果=K；时间复杂度为O(n)。

  ​        （2）基于堆排序，求前K个最小的数用最大顶堆，求前K个最大的数用最小顶堆。以最大顶堆为例，要维护一个大小为K的顶堆，就是先将K个数插入堆中，随后，对每一个数，与堆顶的最大元素比较，若该数比堆顶元素小，则替换掉堆顶元素，然后调整堆，若大于堆顶元素，则不管，那么将所有元素比较和插入后，该堆维护的就是最小的K个数。求前k小的数用最大顶堆的目的(原理）：这是一种局部淘汰的思想，尽量的把小的数都放在堆中，最后使得即使堆中最大的数，也比外界的所有数都小，就达到了目的。

- **如何用栈实现一个队列？**

  ```cpp
  class MyQueue {
  public:
      MyQueue() {
  
      }
      
      void push(int x) {
          stk1.push(x);
      }
      
      int pop() {
          peek();
  
          int res = stk2.top();
          stk2.pop();
  
          return res;
      }
      
      int peek() {
          if (stk2.empty()) {
              while (!stk1.empty()) {
                  stk2.push(stk1.top());
                  stk1.pop();
              }
          }
  
          return stk2.top();
      }
      
      bool empty() {
          return stk1.empty() && stk2.empty();
      }
  
  private:
      stack<int> stk1, stk2;
  };
  ```

- **队列实现栈**

  ```cpp
  class MyStack {
  public:
      void push(int x) {
          q1.push(x);
      }
      // 移除并返回栈顶元素
      int pop() {
          // 栈顶，即队尾元素
          while (q1.size() > 1) {
              q2.push(q1.front());
              q1.pop();
          }
          int res = q1.front();
          q1.pop();
          while (q2.size() > 0) {
              q1.push(q2.front());
              q2.pop();
          }
  
          return res;
      }
      
      int top() {
          while (q1.size() > 1) {
              q2.push(q1.front());
              q1.pop();
          }
          int res = q1.front();
          q2.push(q1.front());
          q1.pop();
          while (q2.size() > 0) {
              q1.push(q2.front());
              q2.pop();
          }
  
          return res;
      }
      
      bool empty() {
          return q1.empty();
      }
  
  private:
      queue<int> q1;
      queue<int> q2;
  };
  ```

### 工程问题

#### **3.1 编译链接原理，从C++源文件到可执行文件的过程？**

答：包括四个阶段：预处理阶段、编译阶段、汇编阶段、链接阶段。

​	（1）预处理阶段处理头文件包含关系，对预编译命令进行替换，生成预编译文件；

​	（2）编译阶段将预编译文件编译，生成汇编文件（编译的过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码)；

​	（3）汇编阶段将汇编文件转换成机器码，生成可重定位目标文件（.obj文件）（汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可）；

​	（4）链接阶段，将多个目标文件和所需要的库链接成可执行文件（.exe文件）。

- **动态链接和静态链接的区别，动态链接的原理是什么？**

  答：**区别**：它们的最大区别就是链接的时机不同，静态链接是在形成可执行程序前，而动态链接的进行则是程序执行时。

  **静态库**：就是将库中的代码包含到自己的程序之中，每个程序链接静态库后，都会包含一份独立的代码，当程序运行起来时，所有这些重复的代码都需要占用独立的存储空间，显然很浪费计算机资源。

  **动态库**：不会将代码直接复制到自己程序中，只会留下调用接口，程序运行时再去将动态库加载到内存中，所有程序只会共享这一份动态库，因此动态库也被称为共享库。

  **动态链接原理**：是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

- **如果头文件定义了函数，源文件不实现，会在哪个环节报错？如果构建的是静态库，会报错吗，为什么？**

  答：在编译这一步中不会报错，如果函数在头文件中声明但未在相应的源文件中定义，编译器**不会**报错，因为编译是逐文件进行的，此时编译器只检查语法正确性，不检查函数是否实现；链接器将所有的目标文件和必要的库文件合并成最终的可执行文件或库文件。如果某个函数被调用但未定义（即没有实现），链接器将无法解析这个函数的引用，因此会报“未解析的外部符号”错误。

  当构建的是静态库时，情况略有不同。

  - **静态库**（通常是`.a`或`.lib`文件）是一组编译过的目标文件的集合，打包成一个单独的文件。创建静态库时，链接器不会尝试解析外部符号，因为静态库本身并不是最终的可执行文件。它只是一个在将来链接成可执行文件或动态库时可以被重用的目标文件的集合。

  因此，如果头文件中声明了一个函数但源文件中未实现，且这个函数**没有在静态库的其他部分被调用**，那么在构建静态库的过程中通常**不会报错**。错误会出现在将这个静态库链接到可执行文件或动态库时，如果有代码尝试调用那个未实现的函数，链接器将报错，因为它找不到该函数的定义。

#### **3.2 如何拷贝一段数据？**

答：（1）C++语法：std::copy(src.begin(), src.end(), dest.begin())；std::copy_n(src.begin(), int n, dest.begin())；

​	（2）C风格语法：memcpy(void* dest, const void* src, size_t num)

#### 3.3 对象池思想

答：对于那些需要频繁创建和销毁的对象，对象池的思想是，首先从对象池中寻找有没有可用的对象，如果没有，就创建对象来使用，然后当一个对象不使用的时候，不是把它删除，而是将它设置为不激活的状态并放入对象池中，等待需要使用的时候再去对象池中寻找，并把它激活。

### 计算机网络

- **TCP和UDP区别**

  答：UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景

  - 无连接，发送数据之前不需要建立连接。
  - 尽最大努力交付，不保证可靠交付，不使用拥塞控制。
  - 面向报文，适合多媒体通信。
  - 支持一对一，一对多，多对一，多对多的交互通信。
  - 首部开销小，8个字节。

  TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议， POP3、SMTP等邮件传输的协议

  - 面向连接。
  - 每一条TCP有且只有两个端点，为一对一关系。
  - 提供可靠交付。
  - 全双工通信，全双工为既可传输又可接收。
  - 面向字节流。

- **TCP第三次握手**

  答：第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
  第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
  第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

- **为什么要进行三次握手**

  答：防止A以前遗失在网络中的请求和B直接建立连接，死锁B。

   现假定一种异常情况，A发出的第一个连接请求报文段被长时间滞留在某些网络结点了，以致延误到连接释放后的某个时间到达B。本来这是一个早已经失效的报文段，但是B收到此失效的连接请求报文段后，就误认为是A又发出一次连接新的请求。于是就向A发出来确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。
  由于A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发送数据，B的许多资源就白白浪费了！！！

  采用三次握手的方法可以防止上述现象发生。例如刚刚的情况，A不会向B的确认而发出确认。B由于收不到确认，就知道A并没有要求建立连接。

- **为什么要四次挥手**

  答：TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

- **第二次、第三次挥手为什么不能合并？**

  答：第二次挥手是因为服务器**B**可能还没传完，先回应一声，然后接着传，传完挥手第三次。

- **如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？**

  答：客户端没有收到 ACK 确认，会重新发送 FIN 请求。

- **为什么还要挥手第四次？**

  答：因为第三次挥手有可能丢失，客户端**A**就会一直等待，所以需要第四次挥手确认。

- **为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？**

  答：第四次挥手有可能丢失，服务器B收不到会重新请求，所以客户端A等一会就是为了怕第四次挥手失败。如果第四次挥手失败，B没收到且A如果没等，A就接收不到B的重新请求，B就永远收不到第四次挥手，处于死锁。A等了2MSL还没收到B重新请求，就判定B接受到了第四次挥手，此时断开TCP链接。

### 操作系统

#### 4.1 **虚拟内存有什么用？**

答：第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域；第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题；第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

#### **4.2 系统内存紧张了会怎么办？**

答：开始回收内存，采用一系列算法，如LRU（最近最久未使用）。

#### **4.3 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？**

答：如果是32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败；64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。

#### **4.4 并发和并行有什么区别？**

答：对于单核CPU，一秒钟内会执行多个进程，这就是并发；对于多核CPU，可以多个进程一块执行，这就是并行。

#### **4.5 进程的7种状态**

如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。**描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态**。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

<img src="https://cdn.jsdelivr.net/gh/qzlu-cyber/PicgoLib@main/images/202403141758493.png" style="zoom:50%;"/>

#### **4.6 进程和线程的比较**

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

对于，线程相比进程能减少开销，体现在：

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

#### **4.7 忙等待锁和无忙等待锁**

答：忙等待锁：

```cpp
int TestAndSet (int* old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}

void func(lock_t* lock) {
    // 加锁
    while (TestAndSet(lock->flag, 1) == 1);
    // 访问临界区
    ...
    // 解锁
    lock->flag = 0;
}
```

- 第一个场景是，首先假设一个线程在运行，调用 `func()`，没有其他线程持有锁，所以 `flag` 是 0。当调用 `TestAndSet(flag, 1)` 方法，返回 0，线程会跳出 `while` 循环，获取锁。同时也会原子的设置 `flag` 为1，标志锁已经被持有。当线程离开临界区，解锁将 `flag` 清理为 0。
- 第二种场景是，当某一个线程已经持有锁（即 `flag` 为1）。本线程调用 `func()`，然后调用 `TestAndSet(flag, 1)`，这一次返回 1。只要另一个线程一直持有锁，`TestAndSet()` 会重复返回 1，本线程会一直**忙等**。当 `flag` 终于被改为 0，本线程会调用 `TestAndSet()`，返回 0 并且原子地设置为 1，从而获得锁，进入临界区。

无忙等待锁：

```cpp
int TestAndSet (int* old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}

void func(lock_t* lock) {
    // 加锁
    while (TestAndSet(lock->flag, 1) == 1) {
        保存当前线程 TCB
        将当前线程 TCB 插入到等待队列
        设置该线程状态
        调度程序
    }
    // 访问临界区
    ...
    // 解锁
    if (等待队列不为空) {
        移出等待队列队头元素
        将该线程 TCB 插入到就绪队列
        设置线程状态
    }
    lock->flag = 0;
}
```
